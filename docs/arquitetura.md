# üìò Documento de Arquitetura ‚Äì Backend

## 1\. Vis√£o Geral

O backend tem como objetivo **automatizar a classifica√ß√£o de NCM e c√°lculo de al√≠quotas** a partir de PDFs de pedidos de compra que cont√™m partnumbers de produtos tecnol√≥gicos. O sistema utiliza **Flask** como framework principal, aproveitando sua flexibilidade e suporte para comunica√ß√£o em tempo real via **WebSockets**.

O fluxo principal da aplica√ß√£o segue as etapas abaixo:

1.  O usu√°rio faz login, autenticando-se com tokens JWT.
2.  Faz o upload de um PDF, que √© recebido pela API.
3.  A API inicia um processamento em segundo plano, delegando a tarefa para um **worker ass√≠ncrono (Celery)**.
4.  O worker extrai os partnumbers do PDF, busca especifica√ß√µes, e classifica o produto no NCM via agentes de IA.
5.  O sistema calcula as al√≠quotas correspondentes ao NCM.
6.  O resultado √© salvo no banco de dados e enviado para a interface do Flask.
7.  O Flask, por sua vez, **emite um evento via WebSocket** para o frontend, enviando o resultado final em tempo real.
8.  O usu√°rio pode alterar informa√ß√µes incorretas e salvar as corre√ß√µes.
9.  O resultado final pode ser exportado em JSON ou Excel.
10. O usu√°rio pode consultar o hist√≥rico de todas as suas opera√ß√µes.

O sistema ser√° implementado em uma **arquitetura monol√≠tica modular**, pois essa abordagem equilibra a agilidade de desenvolvimento com a organiza√ß√£o, facilitando o trabalho em equipe e a manuten√ß√£o.

-----

## 2\. Camadas da Aplica√ß√£o

### Camada de Apresenta√ß√£o (Interface de API & WebSockets)

  * **Framework:** Flask
  * **Responsabilidade:** Receber requisi√ß√µes HTTP (RESTful) e gerenciar a comunica√ß√£o em tempo real com o frontend via WebSockets.
  * **Caracter√≠sticas:** Stateless (autentica√ß√£o via JWT) e documenta√ß√£o da API com ferramentas como `Flassger` ou `apifairy`.

### Camada de Aplica√ß√£o (Orquestra√ß√£o de Casos de Uso)

  * **Responsabilidade:** Servir como a espinha dorsal do fluxo de trabalho, coordenando a execu√ß√£o das regras de neg√≥cio.
  * **Caracter√≠sticas:** Gerencia a delega√ß√£o de tarefas para a fila do **Celery** e orquestra a comunica√ß√£o entre os m√≥dulos de dom√≠nio.

### Camada de Dom√≠nio (Regras de Neg√≥cio)

  * **Responsabilidade:** Cont√©m a l√≥gica de neg√≥cio central do sistema.
  * **Caracter√≠sticas:** Define as entidades do sistema (Usu√°rio, Opera√ß√£o, Produto, Classifica√ß√£oNCM) e a l√≥gica de classifica√ß√£o h√≠brida (heur√≠sticas + IA).

### Camada de Infraestrutura

  * **Responsabilidade:** Fornecer os servi√ßos de suporte para a aplica√ß√£o.
  * **Caracter√≠sticas:** Inclui o **PostgreSQL** para persist√™ncia, o **Redis** para mensageria ass√≠ncrona, e o **Ollama** para executar os modelos de IA localmente.

-----

## 3\. M√≥dulos da Aplica√ß√£o

Cada m√≥dulo √© implementado como um **componente interno do monolito**, projetado segundo o princ√≠pio de **Responsabilidade √önica**. O objetivo √© reduzir o acoplamento e facilitar o desenvolvimento paralelo. O desenvolvimento deve se guiar pelas defini√ß√µes abaixo. O projeto segue Mon√≥lito Modular com forte inspira√ß√£o em:

  - **Single Responsibility Principle (SRP)**: Cada m√≥dulo foi definido com uma √∫nica responsabilidade clara, evitando sobreposi√ß√£o de fun√ß√µes. Isso garante baixo acoplamento (m√≥dulos independentes entre si) e alta coes√£o (cada m√≥dulo focado em uma √∫nica tarefa).
  - **Layered Architecture / Clean Architecture**: .
  - **Orchestration Pattern para a IA**:

-----

### 0\. **API Module (Interface de API & WebSockets)**

**Responsabilidade √önica:**
Servir como a fachada do sistema, expondo a interface p√∫blica (REST e WebSockets) e traduzindo requisi√ß√µes externas para chamadas internas da aplica√ß√£o.

**Responsabilidades Detalhadas:**

  * Definir e expor endpoints (ex: login, upload, consulta, hist√≥rico).
  * Validar dados de entrada.
  * Gerenciar autentica√ß√£o e autoriza√ß√£o via JWT.
  * Receber uploads de PDF e enfileirar a tarefa de processamento no Celery.
  * Gerenciar conex√µes de WebSocket e emitir eventos para o cliente.

**Tecnologias Sugeridas:**

  * **Framework:** Flask
  * **Valida√ß√£o:** `Flask-WTF` ou `Marshmallow`
  * **Mensageria:**  `Celery` (Processamento ass√≠ncrono), `Redis`(Broker)
  * **WebSockets:** `Flask-SocketIO` e `eventlet` ou `gevent`
  * **Autentica√ß√£o:** `Flask-JWT-Extended`

**Atributos adicionais:**

  * **Padroniza√ß√£o:** As rotas seguem conven√ß√µes REST.
  * **Acessibilidade:** A comunica√ß√£o em tempo real reduz a lat√™ncia percebida pelo usu√°rio.
  * **Seguran√ßa:** Requisi√ß√µes autenticadas por padr√£o, exceto rotas p√∫blicas.

-----

### 1\. **Auth Module**

**Responsabilidade √önica**:
Gerenciar autentica√ß√£o e autoriza√ß√£o de usu√°rios.

**Responsabilidades Detalhadas (Funcionalidades)**:

  * Registro e login/logout de usu√°rios.
  * Gera√ß√£o e valida√ß√£o de tokens JWT.
  * Armazenamento seguro de credenciais (hash de senhas).
  * Endpoints: `/login`, `/register`, `/logout`.

**Tecnologias Sugeridas**:

  * **Banco**: PostgreSQL.
  * **Autentica√ß√£o**: `Flask-JWT-Extended`.
  * **Seguran√ßa**: `bcrypt` para hashing.

**Atributos adicionais**:

  * **Escalabilidade**: Stateless (tokens n√£o armazenados em sess√£o).
  * **Auditabilidade**: Registra tentativas de login mal-sucedidas.

-----

### 2\. **Upload & Extraction Module**

**Responsabilidade √önica**:
Gerenciar o upload de PDFs e extrair dados relevantes (texto, partnumbers).

**Responsabilidades Detalhadas**:

  * Receber upload de arquivos do Flask.
  * **Tarefa Celery** para extra√ß√£o de texto com bibliotecas de parsing.
  * Normaliza√ß√£o inicial (remo√ß√£o de caracteres especiais, quebra de linhas).
  * Armazenamento tempor√°rio em disco ou bucket.

**Tecnologias Sugeridas**:

  * **Upload**: Flask.
  * **Parsing PDF**: `PyMuPDF` ou `pdfminer.six`.
  * **Armazenamento tempor√°rio**: sistema de arquivos local ou MinIO (compat√≠vel com S3).

**Atributos adicionais**:

  * **Resili√™ncia**: deve suportar PDFs corrompidos sem travar o pipeline.

-----

### 3\. **AI Orchestration Module**

**Responsabilidade √önica**:
Orquestrar agentes de IA especializados para diferentes tarefas.

**Responsabilidades Detalhadas**:

  * Gerenciar ciclo de execu√ß√£o de agentes SmolAgents.
  * Definir ordem de chamadas: buscar especifica√ß√µes, normalizar, classificar.
  * Repassar resultados entre agentes.
  * Consolidar sa√≠das em formato padronizado para o **Classification Module**.

**Tecnologias Sugeridas**:

  * **Agentes**: SmolAgents.
  * **LLM**: Ollama rodando localmente.
  * **Protocolo interno**: JSON padronizado entre agentes.

**Atributos adicionais**:

  * **Extensibilidade**: novos agentes podem ser plugados sem alterar o restante do sistema.

-----

### 4\. **Classification Module**

**Responsabilidade √önica**:
Aplicar regras de neg√≥cio para classificar produtos em c√≥digos NCM.

**Responsabilidades Detalhadas**:

  * Regras heur√≠sticas (regex, keywords).
  * Classifica√ß√£o sem√¢ntica via embeddings.
  * Consulta em base de NCM armazenada em Postgres.
  * Combina√ß√£o das evid√™ncias (IA + heur√≠sticas + base).
  * Retorno do NCM mais prov√°vel + score de confian√ßa.

**Tecnologias Sugeridas**:

  * **NLP**: Ollama (embeddings).
  * **Heur√≠sticas**: Regex (m√≥dulo `re`).
  * **Banco**: PostgreSQL com tabela NCM.
  * **Busca Vetorial**: FAISS ou `pgvector` (plugin Postgres).

**Atributos adicionais**:

  * **Confiabilidade**: deve registrar todas as evid√™ncias que justificaram a classifica√ß√£o.

-----

### 5\. **Taxation Module**

**Responsabilidade √önica**:
Determinar al√≠quotas e tributos aplic√°veis a partir do NCM classificado.

**Responsabilidades Detalhadas**:

  * Consultar tabela TIPI (Postgres).
  * Associar NCM ‚Üí Al√≠quota correta.
  * Tratar exce√ß√µes (regimes especiais, isen√ß√µes).

**Tecnologias Sugeridas**:

  * **Banco**: PostgreSQL.
  * **Regras adicionais**: camada de neg√≥cio implementada em Python.

**Atributos adicionais**:

  * **Atualiz√°vel**: a tabela TIPI deve permitir updates peri√≥dicos com facilidade.

-----

### 6\. **Reporting Module**

**Responsabilidade √önica**:
Gerar relat√≥rios consolidados de classifica√ß√£o.

**Responsabilidades Detalhadas**:

  * Gera√ß√£o de arquivos Excel com `pandas` + `openpyxl`.
  * Exporta√ß√£o para download via API.

**Tecnologias Sugeridas**:

  * **Relat√≥rios**: `pandas`, `openpyxl`.
  * **Exporta√ß√£o**: Endpoints Flask para download de arquivos.

**Atributos adicionais**:

  * **Padroniza√ß√£o**: relat√≥rios devem seguir template fixo.

-----

### 7\. **History & Audit Module**

**Responsabilidade √önica**:
Registrar e disponibilizar hist√≥rico/auditoria das classifica√ß√µes.

**Responsabilidades Detalhadas**:

  * Registro autom√°tico das opera√ß√µes realizadas.
  * Armazenar opera√ß√µes vinculadas ao usu√°rio.
  * Guardar metadados (partnumber, NCM, score, evid√™ncias).
  * Fornecer consultas hist√≥ricas.

**Tecnologias Sugeridas**:

  * **Banco**: PostgreSQL.
  * **Consulta**: SQL + APIs REST.

**Atributos adicionais**:

  * **Auditabilidade**: registros imut√°veis (sem dele√ß√£o).

-----

### 8\. **Logging & Metrics Module**

**Responsabilidade √önica**:
Gerar logs estruturados e m√©tricas de monitoramento.

**Responsabilidades Detalhadas**:

  * Logging JSON com `structlog`.

  * Exposi√ß√£o de m√©tricas no padr√£o Prometheus.

  * Integra√ß√£o com Grafana para dashboards.

  * KPIs principais:

      * Tempo de processamento por opera√ß√£o.
      * Volume de classifica√ß√µes por usu√°rio.
      * Score m√©dio de confian√ßa.
      * Taxa de erros/falhas.

**Tecnologias Sugeridas**:

  * **Logging**: Python `logging` + `structlog`.
  * **M√©tricas**: Prometheus + Grafana.

**Atributos adicionais**:

  * **Observabilidade**: cada opera√ß√£o deve ser rastre√°vel ponta a ponta.

-----

## 4\. Comunica√ß√£o entre M√≥dulos

  * **Interna (dentro do mon√≥lito):**

      * Via chamadas diretas de fun√ß√£o (baixa lat√™ncia).
      * Camada de aplica√ß√£o (agora um **worker Celery**) chama m√≥dulos de dom√≠nio e infraestrutura.

  * **Externa:**

      * Cliente ‚Üí API REST (Flask).
      * Cliente ‚Üí WebSockets (Flask-SocketIO).
      * **Flask (app principal) ‚Üí Redis (Celery Broker)**.
      * **Worker Celery ‚Üí WebSockets (para enviar resultados)**.
      * Worker Celery ‚Üí Ollama (via HTTP local API).
      * Worker Celery ‚Üí Postgres (via SQLAlchemy ORM).

-----

## 5\. Depend√™ncias entre M√≥dulos

  * **Auth Module** ‚Üí Postgres.
  * **Upload & Extraction** ‚Üí Infraestrutura de arquivos.
  * **AI Orchestration** ‚Üí SmolAgents, Ollama.
  * **Classification** ‚Üí AI Orchestration + Base NCM em Postgres.
  * **Taxation** ‚Üí Classification + Tabelas TIPI (Postgres).
  * **Reporting** ‚Üí Classification + Taxation + Infraestrutura Excel.
  * **History & Audit** ‚Üí Todos os outros (precisa de logs/DB).
  * **Logging & Metrics** ‚Üí Transversal a todos os m√≥dulos.
  * **Mensageria (Celery)** ‚Üí Depende de todos os m√≥dulos de processamento.
  * **WebSockets (Flask-SocketIO)** ‚Üí Depende do worker Celery para receber os resultados e enviar ao frontend.

-----

## 6\. Mapeamento de Tecnologia por M√≥dulo

| M√≥dulo              | Tecnologia / Biblioteca                 |
| :------------------ | :-------------------------------------- |
| Auth                | Flask-JWT-Extended, SQLAlchemy          |
| Upload & Extraction | Flask, PyMuPDF, pdfminer.six            |
| AI Orchestration    | SmolAgents, Ollama (HTTP API local)     |
| Classification      | Regex, heur√≠sticas, Ollama embeddings   |
| Taxation            | Postgres (tabelas TIPI/NCM), SQLAlchemy |
| Reporting           | pandas, openpyxl                        |
| History & Audit     | SQLAlchemy, Postgres                    |
| Logging & Metrics   | structlog, Prometheus, Grafana, Loki    |

-----

## 7\. Tecnologias e Infraestrutura

| Categoria                     | Tecnologia / Ferramenta                                   |
| :---------------------------- | :-------------------------------------------------------- |
| **Linguagem**                 | Python                                                    |
| **Framework API**             | **Flask**                                                 |
| **Mensageria**                | **Celery** (Processamento ass√≠ncrono), **Redis** (Broker) |
| **Comunica√ß√£o em Tempo Real** | **Flask-SocketIO**, `eventlet`                            |
| **Banco de Dados**            | PostgreSQL, SQLAlchemy (ORM)                              |
| **IA Local**                  | **Ollama** (para modelos LLM e embeddings)                |
| **Armazenamento**             | Disco local (dev), MinIO ou S3 (prod)                     |
| **Relat√≥rios**                | `pandas`, `openpyxl`                                      |
| **Observabilidade**           | `structlog`, Prometheus, Grafana                          |
| **Containeriza√ß√£o**           | Docker, Docker-compose                                    |

-----

## 8\. Logger e M√©tricas

  * **Logger:**

      * Formato JSON.
      * N√≠veis: INFO (opera√ß√µes normais), WARN (classifica√ß√£o incerta), ERROR (falhas).
      * Inclui correla√ß√£o por `operation_id` para rastrear todo o fluxo.

  * **M√©tricas (Prometheus):**

      * `operation_processing_time_seconds` (histogram).
      * `ncm_classification_confidence` (gauge).
      * `user_operations_total` (counter).
      * `pdf_upload_errors_total` (counter).

-----

## 9\. Considera√ß√µes de Projeto

  * **Mon√≥lito modular:** Facilita o desenvolvimento em equipe, permitindo que os m√≥dulos sejam trabalhados de forma independente.
  * **Baixo acoplamento e alta coes√£o:** m√≥dulos especializados, comunica√ß√£o bem definida.
  * **Stateless:** API n√£o guarda sess√£o em mem√≥ria; autentica√ß√£o via JWT.
  * **Performance:** **O fluxo de processamento de PDFs agora √© completamente ass√≠ncrono via Celery**, melhorando a experi√™ncia do usu√°rio e a resili√™ncia do sistema.
  * **Seguran√ßa:**
      * Senhas hash com bcrypt.
      * JWT tokens expiram.
      * Sanitiza√ß√£o de inputs.
  * **Confiabilidade:** logs + auditoria para rastreabilidade fiscal.

-----

## Estrutura inicial proposta de diret√≥rios
```
.
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py             # App Factory - Monta a aplica√ß√£o e os m√≥dulos
‚îÇ   ‚îú‚îÄ‚îÄ config.py               # Configura√ß√µes globais
‚îÇ   ‚îú‚îÄ‚îÄ extensions.py           # Inst√¢ncias de extens√µes (db, jwt, socketio)
‚îÇ   ‚îú‚îÄ‚îÄ celery_utils.py         # Configura√ß√£o do Celery
‚îÇ   ‚îú‚îÄ‚îÄ models.py               # Modelos de dados do SQLAlchemy
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py         # Defini√ß√£o da api com flask_restful
|   |
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py           # Endpoints: /login, /register
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schemas.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ upload_extraction/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py           # Endpoint: /upload
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tasks.py            # Tarefa Celery para extrair texto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ai_orchestration/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ document_interpreter_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_researcher_agent.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ncm_classifier_agent.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tasks.py            # Tarefa Celery que executa o pipeline de IA
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services.py         # O servi√ßo "maestro" que coordena os agentes
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ classification/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services.py         # L√≥gica de regras, heur√≠sticas e decis√£o final
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ history_audit/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ routes.py
‚îÇ       ‚îî‚îÄ‚îÄ services.py
‚îÇ
‚îú‚îÄ‚îÄ run.py                      # Ponto de entrada do servidor web
‚îú‚îÄ‚îÄ celery_worker.py            # Ponto de entrada do worker Celery
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ .env.example
```


## Entregas por sprint

### Primeira Entrega
  * Receber um partnumber via um endpoint simples (sem PDF).
  * Encontrar a defini√ß√£o e detalhes do produto.
  * Criar agente de busca na web
  * Enviar o resultado json via WebSocket para o frontend.
  * Construir e validar o pipeline de processamento ass√≠ncrono de ponta a ponta para um √∫nico partnumber.

### Segunda Entrega
  * Extrair partnumbers de arquivo PDF.
  * Encontrar NCM e al√≠quota correspondentes.
  * Salvar o resultado no banco de dados.

### Terceira Entrega
  * Implementar o sistema de login e autentica√ß√£o com JWT.
  * Exportar o resultado final para Excel.
  * Permitir que o usu√°rio acesse o hist√≥rico de suas opera√ß√µes.


## Diagrama
<!-- ![diagrama](./arquitetura.svg) -->
![diagrama](./arquitetura.png)